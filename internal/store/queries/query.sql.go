// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package queries

import (
	"context"
)

const createPR = `-- name: CreatePR :exec
INSERT INTO pull_requests (id, name, author_id, status, assigned_reviewers)
VALUES ($1, $2, $3, 'OPEN', $4)
`

type CreatePRParams struct {
	ID                string   `json:"id"`
	Name              string   `json:"name"`
	AuthorID          string   `json:"author_id"`
	AssignedReviewers []string `json:"assigned_reviewers"`
}

func (q *Queries) CreatePR(ctx context.Context, arg CreatePRParams) error {
	_, err := q.db.Exec(ctx, createPR,
		arg.ID,
		arg.Name,
		arg.AuthorID,
		arg.AssignedReviewers,
	)
	return err
}

const createTeam = `-- name: CreateTeam :exec
INSERT INTO teams (name) VALUES ($1) ON CONFLICT (name) DO NOTHING
`

func (q *Queries) CreateTeam(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, createTeam, name)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, username, team_name, is_active)
VALUES ($1, $2, $3, $4)
    ON CONFLICT (id) DO UPDATE SET
    username = EXCLUDED.username,
                            team_name = EXCLUDED.team_name,
                            is_active = EXCLUDED.is_active
`

type CreateUserParams struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	TeamName string `json:"team_name"`
	IsActive bool   `json:"is_active"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.TeamName,
		arg.IsActive,
	)
	return err
}

const deactivateUsers = `-- name: DeactivateUsers :exec
UPDATE users SET is_active = false WHERE id = ANY($1::text[])
`

func (q *Queries) DeactivateUsers(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, deactivateUsers, dollar_1)
	return err
}

const getActiveUsersInTeamExcluding = `-- name: GetActiveUsersInTeamExcluding :many
SELECT id FROM users
WHERE team_name = $1 AND is_active = true AND id != $2
`

type GetActiveUsersInTeamExcludingParams struct {
	TeamName string `json:"team_name"`
	ID       string `json:"id"`
}

func (q *Queries) GetActiveUsersInTeamExcluding(ctx context.Context, arg GetActiveUsersInTeamExcludingParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getActiveUsersInTeamExcluding, arg.TeamName, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpenPRsByReviewers = `-- name: GetOpenPRsByReviewers :many
SELECT id, assigned_reviewers FROM pull_requests
WHERE status = 'OPEN' AND $1 && assigned_reviewers
`

type GetOpenPRsByReviewersRow struct {
	ID                string   `json:"id"`
	AssignedReviewers []string `json:"assigned_reviewers"`
}

func (q *Queries) GetOpenPRsByReviewers(ctx context.Context, assignedReviewers []string) ([]GetOpenPRsByReviewersRow, error) {
	rows, err := q.db.Query(ctx, getOpenPRsByReviewers, assignedReviewers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOpenPRsByReviewersRow{}
	for rows.Next() {
		var i GetOpenPRsByReviewersRow
		if err := rows.Scan(&i.ID, &i.AssignedReviewers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPR = `-- name: GetPR :one
SELECT id, name, author_id, status, assigned_reviewers, created_at, merged_at
FROM pull_requests WHERE id = $1
`

func (q *Queries) GetPR(ctx context.Context, id string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, getPR, id)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthorID,
		&i.Status,
		&i.AssignedReviewers,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const getPRCountByReviewer = `-- name: GetPRCountByReviewer :many
SELECT unnest(assigned_reviewers) as reviewer_id, COUNT(*) as cnt
FROM pull_requests
WHERE status = 'OPEN'
GROUP BY reviewer_id
`

type GetPRCountByReviewerRow struct {
	ReviewerID interface{} `json:"reviewer_id"`
	Cnt        int64       `json:"cnt"`
}

func (q *Queries) GetPRCountByReviewer(ctx context.Context) ([]GetPRCountByReviewerRow, error) {
	rows, err := q.db.Query(ctx, getPRCountByReviewer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPRCountByReviewerRow{}
	for rows.Next() {
		var i GetPRCountByReviewerRow
		if err := rows.Scan(&i.ReviewerID, &i.Cnt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPRsByReviewer = `-- name: GetPRsByReviewer :many
SELECT id, name, author_id, status
FROM pull_requests
WHERE $1 = ANY(assigned_reviewers)
`

type GetPRsByReviewerRow struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	AuthorID string `json:"author_id"`
	Status   string `json:"status"`
}

func (q *Queries) GetPRsByReviewer(ctx context.Context, assignedReviewers []string) ([]GetPRsByReviewerRow, error) {
	rows, err := q.db.Query(ctx, getPRsByReviewer, assignedReviewers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPRsByReviewerRow{}
	for rows.Next() {
		var i GetPRsByReviewerRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AuthorID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeam = `-- name: GetTeam :one
SELECT name FROM teams WHERE name = $1
`

func (q *Queries) GetTeam(ctx context.Context, name string) (string, error) {
	row := q.db.QueryRow(ctx, getTeam, name)
	err := row.Scan(&name)
	return name, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, team_name, is_active FROM users WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.TeamName,
		&i.IsActive,
	)
	return i, err
}

const getUsersByTeam = `-- name: GetUsersByTeam :many
SELECT id, username, team_name, is_active FROM users WHERE team_name = $1
`

func (q *Queries) GetUsersByTeam(ctx context.Context, teamName string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByTeam, teamName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.TeamName,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergePR = `-- name: MergePR :exec
UPDATE pull_requests
SET status = 'MERGED', merged_at = NOW()
WHERE id = $1 AND status = 'OPEN'
`

func (q *Queries) MergePR(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, mergePR, id)
	return err
}

const setUserActive = `-- name: SetUserActive :exec
UPDATE users SET is_active = $2 WHERE id = $1
`

type SetUserActiveParams struct {
	ID       string `json:"id"`
	IsActive bool   `json:"is_active"`
}

func (q *Queries) SetUserActive(ctx context.Context, arg SetUserActiveParams) error {
	_, err := q.db.Exec(ctx, setUserActive, arg.ID, arg.IsActive)
	return err
}

const updatePRReviewers = `-- name: UpdatePRReviewers :exec
UPDATE pull_requests
SET assigned_reviewers = $2
WHERE id = $1
`

type UpdatePRReviewersParams struct {
	ID                string   `json:"id"`
	AssignedReviewers []string `json:"assigned_reviewers"`
}

func (q *Queries) UpdatePRReviewers(ctx context.Context, arg UpdatePRReviewersParams) error {
	_, err := q.db.Exec(ctx, updatePRReviewers, arg.ID, arg.AssignedReviewers)
	return err
}
